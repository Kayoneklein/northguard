import 'dart:typed_data';

import 'package:intl/intl.dart';
import 'package:northguard/model/team.dart';

import 'attachment.dart';
import 'group.dart';
import 'location.dart';

enum PasswordType { userShare, teamShare }

/// Password generated by user
class Password {
  Password({
    required this.groupIds,
    required this.name,
    required this.user,
    required this.password,
    required this.url,
    required this.note,
    required this.createdAt,
    required this.updatedAt,
    required this.locations,
    required this.files,
    this.oldFiles = const [],
    required this.shares,
    required this.shareChanges,
    required this.shareTeamIds,
    required this.id,
    this.tempId = -1,
    this.creator,
    this.isNewlyShared = false,
    this.isHidden = false,
    this.shareInfo,
    this.icon,
    this.tags = const [],
    this.type,
    this.teamKey,
    this.hashId,
    this.alarm,
  });

  @override
  String toString() {
    return '(name = $name, password = $password)';
  }

  static final _parsableFields = <String>{
    'gid',
    'name',
    'user',
    'pass',
    'url',
    'note',
    'cre',
    'upd',
    'pos',
    'files',
    'shares',
    'sharechanges',
    'shareteams',
    'alarm',
  };

  int tempId = -1;
  String? id;
  PasswordType? type;
  TeamMember? creator;
  String? teamKey;
  bool isNewlyShared = false;
  bool isHidden = false;
  PasswordShareInfo? shareInfo;
  Uint8List? icon;

  final List<String> groupIds;
  final String name;
  final String user;
  final String password;
  final String url;
  final String note;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? alarm;

  List<Group> tags = <Group>[];
  final List<Location> locations;
  final List<Attachment> files;
  final List<OldAttachment> oldFiles;
  final Map<int, List<int>> shares;
  Map<int, List<int>> shareChanges;
  final List<int> shareTeamIds;

  Map<String, dynamic>? _unparsed;
  String? hashId;

  bool get isShared => creator != null; //TODO change logic
  bool get isSharedByTeam => isShared;

  static Password fromJson(Map<String, dynamic> data, {canRemove = true}) {
    final files = _tryParseFiles(data['files']);
    final password = Password(
      groupIds: _tryParseGroupIds(data['gid']),
      name: data['name'],
      user: data['user'],
      password: data['pass'],
      url: data['url'],
      note: data['note'],
      createdAt: _tryParseDateTime(data['cre']),
      updatedAt: _tryParseDateTime(data['upd']),
      alarm: data['alarm'] != null ? _tryParseDateTime(data['alarm']) : null,
      locations: _tryParseLocations(data['pos']),
      files: files.key,
      oldFiles: files.value,
      shares: _tryParseShares(data['shares']),
      shareChanges: _tryParseShareChanges(data['sharechanges']),
      shareTeamIds: _tryParseShareTeamIds(data['shareteams']),
      id: data['id'],
    );

    if (canRemove) {
      data.removeWhere((k, dynamic v) => _parsableFields.contains(k));
    }

    password._unparsed = data;
    return password;
  }

  Map<String, dynamic> toJson() {
    final data = <String, dynamic>{
      'gid': groupIds,
      'name': name,
      'user': user,
      'pass': password,
      'url': url,
      'note': note,
      'cre': createdAt.millisecondsSinceEpoch,
      'upd': updatedAt.millisecondsSinceEpoch,
      'alarm': alarm?.millisecondsSinceEpoch,
      'pos': locations.map((l) => l.toJson()).toList(),
      'files':
          files.map((f) => f.toJson()).toList() +
          oldFiles.map((f) => f.toJson()).toList(),
      'shares': shares.map<String, dynamic>(
        (k, v) => MapEntry<String, dynamic>(k.toString(), v),
      ),
      'sharechanges': shareChanges.map<String, dynamic>(
        (k, v) => MapEntry<String, dynamic>(k.toString(), v),
      ),
      'shareteams': shareTeamIds,
      'id': id,
    };
    if (_unparsed != null) {
      data.addAll(_unparsed!);
    }
    return data;
  }

  Password copyWith({
    int? tempId,
    String? id,
    TeamMember? creator,
    bool? isNewlyShared,
    bool? isHidden,
    PasswordShareInfo? shareInfo,
    Uint8List? icon,
    List<String>? groupIds,
    String? name,
    String? user,
    String? password,
    String? url,
    String? note,
    DateTime? createdAt,
    DateTime? updatedAt,
    DateTime? alarm,
    List<Group>? tags,
    List<Location>? locations,
    List<Attachment>? files,
    Map<int, List<int>>? shares,
    Map<int, List<int>>? shareChanges,
    List<int>? shareTeamIds,
    PasswordType? type,
    String? teamKey,
    String? hashId,
  }) {
    final result = Password(
      tempId: tempId ?? this.tempId,
      creator: creator ?? this.creator,
      isNewlyShared: isNewlyShared ?? this.isNewlyShared,
      isHidden: isHidden ?? this.isHidden,
      shareInfo: shareInfo ?? this.shareInfo,
      icon: icon ?? this.icon,
      groupIds: groupIds ?? this.groupIds,
      name: name ?? this.name,
      user: user ?? this.user,
      password: password ?? this.password,
      url: url ?? this.url,
      note: note ?? this.note,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      alarm: alarm ?? this.alarm,
      tags: tags ?? this.tags,
      locations: locations ?? this.locations,
      files: files ?? this.files,
      shares: shares ?? this.shares,
      shareChanges: shareChanges ?? this.shareChanges,
      shareTeamIds: shareTeamIds ?? this.shareTeamIds,
      id: id ?? this.id,
      type: type ?? this.type,
      teamKey: teamKey ?? this.teamKey,
      hashId: hashId ?? this.hashId,
    );
    result._unparsed = _unparsed;
    return result;
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Password && runtimeType == other.runtimeType && id == other.id;

  @override
  int get hashCode => id.hashCode;
}

//======================================================================================================================

/// Password data prepared to be shared
class PasswordShare {
  PasswordShare({
    required this.name,
    required this.user,
    required this.password,
    required this.url,
    required this.note,
    required this.createdAt,
    required this.updatedAt,
    required this.locations,
    required this.files,
    required this.oldFiles,
    required this.shareTeamIds,
    this.shareUserId,
    this.alarm,
  });

  int? shareUserId;

  final String name;
  final String user;
  final String password;
  final String url;
  final String note;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? alarm;

  final List<Location> locations;
  final List<Attachment> files;
  final List<OldAttachment> oldFiles;
  final List<int> shareTeamIds;

  static PasswordShare fromJson(Map<String, dynamic> data) {
    final files = _tryParseFiles(data['files']);
    return PasswordShare(
      name: data['name'],
      user: data['user'],
      password: data['pass'],
      url: data['url'],
      note: data['note'],
      createdAt: _tryParseDateTime(data['cre']),
      updatedAt: _tryParseDateTime(data['upd']),
      alarm: data['alarm'] != null ? _tryParseDateTime(data['alarm']) : null,
      locations: _tryParseLocations(data['pos']),
      files: files.key,
      oldFiles: files.value,
      shareTeamIds: _tryParseShareTeamIds(data['shareteams']),
    );
  }

  Map<String, dynamic> toJson() => <String, dynamic>{
    'name': name,
    'user': user,
    'pass': password,
    'url': url,
    'note': note,
    'cre': createdAt.millisecondsSinceEpoch,
    'upd': updatedAt.millisecondsSinceEpoch,
    'alarm': alarm?.millisecondsSinceEpoch,
    'pos': locations.map((l) => l.toJson()).toList(),
    'files':
        files.map((f) => f.toJson()).toList() +
        oldFiles.map((f) => f.toJson()).toList(),
    'shareteams': shareTeamIds,
  };
}

//======================================================================================================================

/// Class for (temporary) storing share info of shared passwords
class PasswordShareInfo {
  const PasswordShareInfo({
    required this.username,
    required this.email,
    required this.teams,
    required this.type,
  });

  final String username;
  final String email;
  final List<String> teams;
  final PasswordType? type;
}

//======================================================================================================================

/// Try to parse list of tags
List<String> _tryParseGroupIds(dynamic data) {
  try {
    if (data is int) {
      return [data.toString()];
    }
    if (data is String) {
      return [data];
    }
    if (data is List) {
      return List<String>.from(data.map<String>((dynamic e) => e.toString()));
    }
    return [];
  } catch (error) {
    return [];
  }
}

/// Try to parse date and time
DateTime _tryParseDateTime(dynamic data) {
  if (data is int) {
    return DateTime.fromMillisecondsSinceEpoch(data);
  }
  if (data is double) {
    return DateTime.fromMillisecondsSinceEpoch(data.toInt());
  }
  if (data is String) {
    return DateFormat('yyyy-MM-dd HH:mm:ss').parse(data);
  }
  return DateTime.now();
}

/// Try to parse list of locations
List<Location> _tryParseLocations(dynamic data) {
  try {
    return List<Location>.from(data.map((dynamic l) => Location.fromJson(l)));
  } catch (error) {
    return [];
  }
}

/// Try to parse list of files
MapEntry<List<Attachment>, List<OldAttachment>> _tryParseFiles(dynamic data) {
  try {
    final newFiles = <Attachment>[];
    final oldFiles = <OldAttachment>[];
    for (dynamic l in data) {
      if (l['data'] != null) {
        oldFiles.add(OldAttachment.fromJson(l));
      } else {
        newFiles.add(Attachment.fromJson(l));
      }
    }
    return MapEntry(newFiles, oldFiles);
  } catch (error) {
    return const MapEntry([], []);
  }
}

/// Try to parse password shares
Map<int, List<int>> _tryParseShares(dynamic data) {
  try {
    if (data != null && data is Map<String, dynamic>) {
      return Map<int, List<int>>.fromIterable(
        data.entries.where(
          (e) => int.tryParse(e.key) != null && e.value is List,
        ),
        key: (dynamic e) => int.parse(e.key),
        value: (dynamic e) => List<int>.from(e.value),
      );
    } else {
      return {};
    }
  } catch (error) {
    return {};
  }
}

/// Try to parse password share changes
Map<int, List<int>> _tryParseShareChanges(dynamic data) {
  try {
    if (data != null && data is Map<String, dynamic>) {
      return Map<int, List<int>>.fromIterable(
        data.entries.where((e) => int.tryParse(e.key) != null),
        key: (dynamic e) => int.parse(e.key),
        value: (dynamic e) => e.value,
      );
    } else {
      return {};
    }
  } catch (error) {
    return {};
  }
}

/// Try to parse password share teams
List<int> _tryParseShareTeamIds(dynamic data) {
  try {
    if (data != null && data is List<dynamic>) {
      return List<int>.from(data);
    } else {
      return [];
    }
  } catch (error) {
    return [];
  }
}
